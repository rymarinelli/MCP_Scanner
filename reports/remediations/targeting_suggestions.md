# Targeting suggestions for `src/mcp_scanner/llm_risk_examples.py`

| Risk tag | Location | Vulnerability summary | Targeted remediation suggestions |
| --- | --- | --- | --- |
| `prompt_injection` | `build_prompt` (lines 28-40) | The legacy logic concatenates raw `user_input` straight into the system prompt, so malicious instructions or code fences are interpreted literally by downstream LLMs. | Treat untrusted text as inert data: normalize newlines, escape or quote Markdown/code-fence tokens, impose a maximum length (4k chars is sufficient for our DSPy prompts), and clearly label the inserted content (for example prefixing every line with `> `). Consider rejecting empty input with a placeholder token so the prompt template stays well-formed. |
| `insecure_model_invocation` | `invoke_insecure_model` (lines 63-90) | The example currently posts prompts to `http://insecure-model.local/invoke` with `verify=False`, allowing MITM and certificate-stripping attacks. | Require `https` URLs (raise when a caller passes `http`), honour `MCP_SECURE_MODEL_URL`, and always call `requests.post(..., verify=True, timeout=30)`. Bubble up `response.raise_for_status()` so CI catches transport failures, and accept an injectable session object to simplify unit testing. |
| `unsafe_tool_execution` | `execute_tool_response` (lines 42-62) | LLM-provided commands are run via `subprocess.run(..., shell=True)` with no allow-listing, enabling arbitrary code execution. | Split the generated command with `shlex.split`, look up the binary in an explicit allow-list that maps friendly aliases (`"list"`) to canonical argv (`["ls", "-la"]`), and execute via `subprocess.run(args, check=False)` without `shell=True`. Surface violations as `ValueError` so the agent loop can report the failure safely. |
| `unsafe_tool_execution` | `dispatch_with_os_system` (lines 92-119) | The helper hands an LLM-written script to `os.system`, inheriting the host shellâ€™s parsing semantics and bypassing validation. | Replace `os.system` with the same allow-list/runner strategy as `execute_tool_response`: parse with `shlex.split`, reject empty commands, and ensure the executable appears in a curated list such as `("bash", "python3")`. Offer dependency injection of a runner function so tests can assert on the final argv without spawning subprocesses. |

These suggestions can be implemented independently. Each bullet isolates a single risky helper so follow-up commits can focus on one vulnerability at a time while keeping the surrounding API unchanged.
